const Default = {
    "lineWidth": 2,
    "strokeStyle": "#222222",
    "lineCap": "butt",
    "lineJoin": "mitter",
    "backgroundColor": null
};

const sigpadMap = new Map();

// finished param: only draw last point after points wont differ from exec to exec
function drawPoints(ctx, stroke, finished) {
    // draw a point instead
    if (stroke.points.length == 1 && stroke.drawnTo == 0) {
        var b = stroke.points[0];
        ctx.beginPath(), ctx.arc(b.x, b.y, ctx.lineWidth / 2, 0, Math.PI * 2, !0), ctx.closePath(), ctx.fill();
        stroke.drawnTo = 1;
        return
    }

    // draw line for just two points
    if (stroke.points.length == 2 && stroke.drawnTo <= 2 && finished) {
        ctx.beginPath(), ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
        ctx.lineTo(stroke.points[1].x, stroke.points[1].y);
        ctx.stroke();
        stroke.drawnTo = 2;
        return
    }

    // draw a bunch of quadratics, using the average of two points as the control point
    if (stroke.points.length >= 3 && stroke.points.length - stroke.drawnTo >= 3) {
        var i
        if (stroke.drawnTo <= 2) {
            i = 0;
            ctx.beginPath(), ctx.moveTo(stroke.points[i].x, stroke.points[i].y);
        } else {
            i = stroke.drawnTo;
            var curPt = stroke.points[i];
            var nxtPt = stroke.points[i + 1];
            var c = (curPt.x + nxtPt.x) / 2,
                d = (curPt.y + nxtPt.y) / 2;
            ctx.beginPath(), ctx.moveTo(c, d);
        }
        i++;
        for (; i < stroke.points.length - 2; i++) {
            var curPt = stroke.points[i];
            var nxtPt = stroke.points[i + 1];
            var c = (curPt.x + nxtPt.x) / 2,
                d = (curPt.y + nxtPt.y) / 2;
            ctx.quadraticCurveTo(curPt.x, curPt.y, c, d);
            stroke.drawnTo = i;
        }
        if (i < stroke.points.length - 1 && finished) {
            ctx.quadraticCurveTo(stroke.points[i].x, stroke.points[i].y, stroke.points[i + 1].x, stroke.points[i + 1].y);
            stroke.drawnTo = i + 1;
        }
        //ctx.closePath();
        ctx.stroke();
    }
}
export default class Sigpad {


    static getOrCreateInstance(element, config) {
        return this.getInstance(element.id) || new this(element, typeof config === 'object' ? config : null)
    }

    static getInstance(id) {
        var pads = [...sigpadMap].filter(([k, v]) => k.id == id)
        if (pads.length > 0) {
            return pads[0][1];
        }
        return null;
    }

    static getAllInstances() {
        var instances = [];
        sigpadMap.forEach((value, key, map) => {
            instances.push(value);
        });
        return instances;
    }

    constructor(element, options) {
        if (!sigpadMap.has(element)) {
            sigpadMap.set(element, this);
        }

        this._config = this._getConfig(options);
        this._element = element;
        this._mousePosis = [];
        this._drawing = false;

        this._setListeners();
        this._applyOptions();

        this._element.width = this._element.clientWidth;
        this._element.height = this._element.clientHeight;
    }

    destroy() {
        if (!sigpadMap.has(this._element)) {
            return
        }

        sigpadMap.delete(this._element);

        this._element.removeEventListener("mousedown", this._onStart);
        this._element.removeEventListener("mouseup", this._onEnd);
        this._element.removeEventListener("mousemove", this._onMove);

        this._element.removeEventListener("touchstart", this._onStart);
        this._element.removeEventListener("touchend", this._onEnd);
        this._element.removeEventListener("touchmove", this._onMove);
    }

    _applyOptions(ctx = null) {
        if (ctx == null) {
            ctx = this._element.getContext("2d");
        }
        ctx.strokeStyle = this._config.strokeStyle;
        ctx.fillStyle = this._config.strokeStyle;
        ctx.lineWidth = this._config.lineWidth;
        ctx.lineCap = this._config.lineCap;
        ctx.lineJoin = this._config.lineJoin;
    }

    _getRelativeMousePos(e) { 
        var r = this._element.getBoundingClientRect();

        var x = e.clientX;
        var y = e.clientY;

        var startX = r.left;
        var startY = r.top;
        var w = r.right - r.left;
        var h = r.bottom - r.top;
          
        return {
            x: x - startX,
            y: y - startY
        };
    }

    clear() {
        this._mousePosis = [];
        var ctx = this._element.getContext("2d");
        ctx.clearRect(0, 0, this._element.width, this._element.height);
        ctx.save();

        this._drawing = false;

    }

    getImage() {
        return this._element.toDataURL();
    }

    setImage(image) {
        var ctx = this._element.getContext("2d");
        ctx.imageSmoothingEnabled = false;

        if (this._config.backgroundColor != null && this._config.backgroundColor != "") {
            ctx.fillStyle = this._config.backgroundColor;
        }

        if (this._config.backgroundImage != null && this._config.backgroundImage != "") {
            this.setBackgroundImage(this._config.backgroundImage);
        }


        this._img = new Image();
        var t = this;
        this._img.onload = function () {
            ctx.clearRect(0, 0, t._element.width, t._element.height);
            ctx.drawImage(t._img, 0, 0);
        };

        this._img.src = image;
    }

    setBackgroundImage(image) {
        var ctx = this._element.getContext("2d");
        ctx.imageSmoothingEnabled = false;

        if (this._config.backgroundImage != null && this._config.backgroundImage != "") {
            image = this._config.backgroundImage;
        }

        this._bgImg = new Image();
         
        var t = this;
        this._bgImg.onload = function () {
            ctx.clearRect(0, 0, t._element.width, t._element.height);
            ctx.drawImage(t._bgImg, 0, 0,
                t._bgImg.width * window.devicePixelRatio,
                t._bgImg.height * window.devicePixelRatio,
                0, 0,
                t._bgImg.width * window.devicePixelRatio,
                t._bgImg.height * window.devicePixelRatio);

            if (t._img != undefined && t._img.complete) {
                ctx.drawImage(t._img, 0, 0);
            }
        };
        this._bgImg.src = image;
    }

    _getConfig(config) {
        return {
            ...Default,
            ...config,
            ...(typeof config === 'object' && config ? config : {})
        }
    }


    _setListeners() {
        var instance = this;
        this._element.addEventListener("mousedown", this._onStart);
        document.addEventListener("mouseup", function (mouseEvent) { instance._onEnd(instance, mouseEvent); }, { capture: true });
        document.addEventListener("mousemove", function (mouseEvent) { instance._onMove(instance, mouseEvent); }, { capture: true });

        this._element.addEventListener("touchstart", this._onStart);
        document.addEventListener("touchend", function (mouseEvent) { instance._onEnd(instance, mouseEvent); }, { capture: true });
        document.addEventListener("touchmove", function (mouseEvent) { instance._onMove(instance, mouseEvent); }, { capture: true });
    }

    _onStart(mouseEvent) {
        mouseEvent.preventDefault();
        if ("touches" in mouseEvent) {
            mouseEvent = mouseEvent.touches[0];
        }

        var data = Sigpad.getInstance(this.id);

        if (data._element.classList.contains('disabled')) {
            return;
        }

        var mousePos = data._getRelativeMousePos(mouseEvent);
        if (mousePos != null) {
            data._mousePosis.unshift({ drawnTo: 0, points: [mousePos] });
            data._drawing = true;

            const event = new CustomEvent('sigpad.start', { detail: data.getImage() });
            data._element.dispatchEvent(event);
        }
    }

    _onEnd(sender, mouseEvent) {
        if (!this._drawing) return;
        this._drawing = false;

        mouseEvent.preventDefault();
        if ("touches" in mouseEvent) {
            mouseEvent = mouseEvent.touches[0];
        }

        var data = Sigpad.getInstance(sender._element.id);
        if (data._element.classList.contains('disabled')) {
            return;
        }

        data.render(true);

        const event = new CustomEvent('sigpad.finish', { detail: data.getImage() });
        data._element.dispatchEvent(event);
    }

    _onMove(sender, mouseEvent) {
        if (!this._drawing) return;
        //mouseEvent.preventDefault();
        if ("touches" in mouseEvent) {
            mouseEvent = mouseEvent.touches[0];
        }

        var data = Sigpad.getInstance(sender._element.id);

        if (data._element.classList.contains('disabled')) {
            return;
        }

        if (data._drawing) {
            var pos = data._getRelativeMousePos(mouseEvent);
            if (pos != null) {
                data._mousePosis[0].points.push(pos);
                const event = new CustomEvent('sigpad.move', {});
                data._element.dispatchEvent(event);
                data.render(false);
            } else {
                console.log("OUT OF BOUNDS")
                if (data._mousePosis[0].points.length > 0)
                    data._mousePosis.unshift({ drawnTo: 0, points: [] });
                data._onEnd(mouseEvent);
            }
        }
    }

    //finished: signal to renderer that all individual mouse position arrays are complete
    render(finished) {
        if (this._element.width != this._element.clientWidth) {
            this._element.width = this._element.clientWidth;
        }

        if (this._drawing || finished) {
            var ctx = this._element.getContext("2d");
            this._applyOptions(ctx);
            this._mousePosis.filter((stroke) => stroke.points.length > 0).forEach((stroke) => drawPoints(ctx, stroke, finished));
        }
    }
}

//const requestAnimFrame = (function (callback) {
//    return window.requestAnimationFrame ||
//        window.webkitRequestAnimationFrame ||
//        window.mozRequestAnimationFrame ||
//        window.oRequestAnimationFrame ||
//        window.msRequestAnimaitonFrame ||
//        function (callback) {
//            window.setTimeout(callback, 1000 / 144);
//        };
//})();

//(function renderSignatures() {
//    requestAnimFrame(renderSignatures);
//    Sigpad.getAllInstances().forEach((sigpad, index) => {
//        sigpad.render(false);
//    });

//})();
